# -*- coding: utf-8 -*-
"""é»„é‡‘æŠ•èµ„AIå†³ç­–é›·è¾¾ä¸»ç¨‹åº

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d8vVoPuxgkZlQtSVNy5D7Jb-Y2TxLUVp
"""

import streamlit as st
import yfinance as yf
import pandas as pd
import feedparser
from datetime import datetime

# --- Page Configuration ---
st.set_page_config(page_title="é»„é‡‘æŠ•èµ„ AI å†³ç­–å®¤", page_icon="ğŸ†", layout="wide")

# --- Core Logic: Data Retrieval (Cache 1 hour for hourly updates) ---
@st.cache_data(ttl=3600)
def get_financial_data():
    """Fetches key financial data (Gold, DXY, VIX, TNX) on a 1-hour interval for 1 month."""
    # Define assets to monitor
    tickers = {
        'é»„é‡‘ (Gold)': 'GC=F',
        'ç¾å…ƒæŒ‡æ•° (DXY)': 'DX-Y.NYB',
        '10å¹´ç¾å€ºæ”¶ç›Šç‡': '^TNX',
        'ææ…ŒæŒ‡æ•° (VIX)': '^VIX', # Geopolitical risk proxy
        'æ ‡æ™®500': '^GSPC'
    }

    data_store = {}

    # Download 1-month data with 1-hour intervals
    for name, symbol in tickers.items():
        try:
            # Use pre/post market data if available for continuous charting
            df = yf.download(symbol, period="1mo", interval="1h", progress=False, prepost=True)
            if not df.empty:
                data_store[name] = df
        except Exception as e:
            # Log the error but don't stop the app
            print(f"Failed to fetch {name} ({symbol}): {e}")

    return data_store

# --- Core Logic: News Scraping (Political/Macro) ---
# **é‡è¦æ›´æ–°ï¼šå°†ç¼“å­˜æ—¶é—´ç¼©çŸ­è‡³ 5 åˆ†é’Ÿ (300ç§’) ä»¥å®ç°æ›´å¿«çš„é‡åŒ–æ–°é—»åˆ·æ–°**
@st.cache_data(ttl=300)
def get_news():
    """Fetches recent financial news from RSS feeds."""
    rss_urls = [
        "https://search.cnbc.com/rs/search/combinedcms/view.xml?partnerId=wrss01&id=10000664", # CNBC Finance
        "https://feeds.content.dowjones.io/public/rss/mw_topstories" # Market Watch Top Stories
    ]
    news_items = []

    for url in rss_urls:
        try:
            feed = feedparser.parse(url)
            # Take the top 5 entries from each source
            for entry in feed.entries[:5]:
                # Convert time format if possible
                published_time = entry.get('published', 'åˆšåˆš')
                try:
                    # Attempt to parse common RSS date formats
                    # Note: The format string needs to handle the RSS timezone offset if present
                    dt = datetime.strptime(published_time, '%a, %d %b %Y %H:%M:%S %z')
                    published_time = dt.strftime('%Y-%m-%d %H:%M')
                except:
                    pass # Keep 'åˆšåˆš' or original string if parsing fails

                news_items.append({
                    'title': entry.title,
                    'link': entry.link,
                    'published': published_time
                })
        except Exception as e:
             print(f"Failed to fetch RSS from {url}: {e}")

    return news_items

# --- Core Logic: AI Scoring System with Robustness ---
def calculate_signal(data):
    """Calculates a numerical score and reasons based on financial data."""
    score = 0
    reasons = []

    # --- 1. Gold Technical Analysis (MA & RSI) ---
    gold_df = data.get('é»„é‡‘ (Gold)')
    if gold_df is not None and not gold_df.empty:
        # Use .item() to ensure a scalar value is extracted, preventing "ambiguous" error
        current_price = gold_df['Close'].iloc[-1].item()
        gold_series = gold_df['Close']

        # 1.1 Moving Average (MA) Calculation with Fallback
        required_ma_points = 50
        fallback_period = 10

        if len(gold_series) >= required_ma_points:
            # Use .item() to ensure a scalar value
            ma_value = gold_series.rolling(required_ma_points).mean().iloc[-1].item()
            ma_period = required_ma_points
        elif len(gold_series) >= fallback_period:
            # Use .item() to ensure a scalar value
            ma_value = gold_series.rolling(fallback_period).mean().iloc[-1].item()
            ma_period = fallback_period
            reasons.append(f"âš ï¸ å‡çº¿å®¹é”™ï¼šæ•°æ®ä¸è¶³ {required_ma_points} å°æ—¶ï¼Œä½¿ç”¨ {fallback_period} å°æ—¶å‡çº¿è®¡ç®—ã€‚")
        else:
            # If even 10 points are not available, skip MA calculation
            ma_value = current_price # Default to current price to avoid division by zero/NaN issues
            ma_period = 0
            reasons.append("ğŸš« å‡çº¿è·³è¿‡ï¼šæ•°æ®ç‚¹å¤ªå°‘ï¼Œæ— æ³•è®¡ç®—ä»»ä½•å‡çº¿ã€‚")

        if ma_period > 0:
            if current_price > ma_value:
                score += 2
                reasons.append(f"ğŸ“ˆ æŠ€æœ¯é¢ï¼šé‡‘ä»·ä½äº{ma_period}å°æ—¶å‡çº¿ä¸Šæ–¹ (çœ‹æ¶¨)")
            else:
                score -= 2
                reasons.append(f"ğŸ“‰ æŠ€æœ¯é¢ï¼šé‡‘ä»·ä½äº{ma_period}å°æ—¶å‡çº¿ä¸‹æ–¹ (çœ‹è·Œ)")

        # 1.2 RSI Calculation (14-period) with Fallback
        required_rsi_points = 14
        rsi = None

        if len(gold_series) >= required_rsi_points:
            delta = gold_series.diff()
            gain = (delta.where(delta > 0, 0)).rolling(required_rsi_points).mean()
            loss = (-delta.where(delta < 0, 0)).rolling(required_rsi_points).mean()
            # Avoid division by zero when loss is 0
            rs = gain / loss.replace(0, 1e-10)
            # Use .item() to ensure a scalar value
            rsi = (100 - (100 / (1 + rs))).iloc[-1].item()
        else:
            reasons.append("ğŸš« RSIè·³è¿‡ï¼šæ•°æ®ç‚¹å¤ªå°‘ï¼Œæ— æ³•è®¡ç®— RSI (éœ€14å°æ—¶)ã€‚")

        if rsi is not None and not pd.isna(rsi):
            reasons.append(f"ğŸ¯ å®æ—¶RSI (14H): {rsi:.2f}")
            if rsi < 30:
                score += 1
                reasons.append("âš¡ RSIæŒ‡æ ‡ï¼šè¿›å…¥è¶…å–åŒºé—´ (åå¼¹æ¦‚ç‡å¤§)")
            elif rsi > 70:
                score -= 1
                reasons.append("âš ï¸ RSIæŒ‡æ ‡ï¼šè¿›å…¥è¶…ä¹°åŒºé—´ (å›è°ƒé£é™©å¤§)")

    # --- 2. Macro Analysis (USD & VIX) ---

    # 2.1 USD Index (DXY)
    dxy_df = data.get('ç¾å…ƒæŒ‡æ•° (DXY)')
    if dxy_df is not None and len(dxy_df) >= 2:
        # Compare current to 24 hours ago (or first available point if less than 24)
        # Use .item() to ensure a scalar value
        dxy_now = dxy_df['Close'].iloc[-1].item()

        # Try to get 24 hours ago, otherwise use the first point as comparison base
        idx_prev = -24 if len(dxy_df) >= 24 else 0
        # Use .item() to ensure a scalar value
        dxy_prev = dxy_df['Close'].iloc[idx_prev].item()

        if dxy_now < dxy_prev:
            score += 2
            reasons.append(f"ğŸ’µ å®è§‚é¢ï¼šç¾å…ƒæŒ‡æ•° ({dxy_now:.2f}) æ—¥å†…ç›¸å¯¹èµ°å¼± (åˆ©å¥½é»„é‡‘)")
        else:
            score -= 2
            reasons.append(f"ğŸ’µ å®è§‚é¢ï¼šç¾å…ƒæŒ‡æ•° ({dxy_now:.2f}) æ—¥å†…ç›¸å¯¹èµ°å¼º (åˆ©ç©ºé»„é‡‘)")

    # 2.2 Volatility Index (VIX - Geopolitical/Fear Proxy)
    vix_df = data.get('ææ…ŒæŒ‡æ•° (VIX)')
    if vix_df is not None and not vix_df.empty:
        # Use .item() to ensure a scalar value
        vix_now = vix_df['Close'].iloc[-1].item()
        reasons.append(f"ğŸ’£ ææ…ŒæŒ‡æ•°VIX: {vix_now:.2f}")
        if vix_now > 20: # High fear
            score += 2
            reasons.append("ğŸ’£ æƒ…ç»ªé¢ï¼šå¸‚åœºææ…ŒæŒ‡æ•°(VIX)è¾ƒé«˜ (é¿é™©èµ„é‡‘æµå…¥)")
        elif vix_now < 13: # Extreme complacency
            score -= 1
            reasons.append("ğŸ•Šï¸ æƒ…ç»ªé¢ï¼šå¸‚åœºæåº¦å¹³é™ (é¿é™©éœ€æ±‚ä½)")

    return score, reasons

# --- UI Rendering ---
def main():
    st.title("ğŸ¥‡ é»„é‡‘æŠ•èµ„ AI å†³ç­–å®¤")

    # Attempt to load data
    try:
        with st.spinner('æ­£åœ¨è¿æ¥å…¨çƒäº¤æ˜“æ‰€ä¸æ–°é—»æº...'):
            data = get_financial_data()
            news = get_news()

            # Check if essential data (Gold) is available
            if 'é»„é‡‘ (Gold)' not in data or data['é»„é‡‘ (Gold)'].empty:
                st.error("æ•°æ®æºè¿æ¥å¤±è´¥æˆ–å¸‚åœºä¼‘å¸‚ä¸­ã€‚è¯·ç¨åå†è¯•æˆ–æ£€æŸ¥å¸‚åœºçŠ¶æ€ã€‚")
                return

            score, reasons = calculate_signal(data)

            # Note the different refresh rates in the summary
            st.markdown(f"*æ•°æ®æ›´æ–°æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} (**æ–°é—»æ¯ 5 åˆ†é’Ÿåˆ·æ–°**ï¼ŒæŠ€æœ¯æŒ‡æ ‡æ¯å°æ—¶åˆ·æ–°)*")

    except Exception as e:
        # Catch unexpected errors during core processing
        st.error(f"ç³»ç»Ÿå¯åŠ¨å¤±è´¥: {e}")
        st.stop()
        return

    # --- Sidebar ---
    with st.sidebar:
        st.header("å…³äºç³»ç»Ÿ")
        st.info("æœ¬ç³»ç»Ÿæ¯å°æ—¶æŠ“å–ç¾è”å‚¨åˆ©ç‡é¢„æœŸ(ç¾å€º)ã€å…¨çƒåœ°ç¼˜æ”¿æ²»ææ…Œåº¦(VIX)å’Œç¾å…ƒèµ°åŠ¿ï¼Œç»¼åˆè®¡ç®—ä¹°å–ä¿¡å·ã€‚")
        st.caption("ç³»ç»Ÿä¾èµ– yfinance è·å–æ•°æ®ï¼Œå¯èƒ½å—å¸‚åœºé—­å¸‚å½±å“æ•°æ®é‡ã€‚")
        if st.button("ğŸ”„ æ‰‹åŠ¨å¼ºåˆ¶åˆ·æ–°æ•°æ®"):
            st.cache_data.clear()
            st.rerun()

    # --- 1. Core Decision Dashboard ---
    st.divider()
    col1, col2, col3 = st.columns([1, 2, 1])

    gold_df = data['é»„é‡‘ (Gold)']
    cur_gold = gold_df['Close'].iloc[-1].item()

    # Calculate difference for the metric
    if len(gold_df) >= 2:
        gold_delta = cur_gold - gold_df['Close'].iloc[-2].item()
    else:
        gold_delta = 0 # Not enough data for delta

    with col1:
        st.metric("å®æ—¶é‡‘ä»· (USD/oz)", f"${cur_gold:.2f}",
                  f"{gold_delta:.2f}")

    with col2:
        # Determine the explicit action based on score
        action = "è§‚æœ› (HOLD)"
        action_style = st.warning

        if score >= 4:
            action = "å¼ºåŠ›ä¹°å…¥ (STRONG BUY)"
            action_style = st.success

        elif score >= 1:
            action = "é€¢ä½ä¹°å…¥ (CAUTIOUS BUY)"
            action_style = st.info

        elif score <= -4:
            action = "å¼ºåŠ›å–å‡º/åšç©º (STRONG SELL)"
            action_style = st.error

        elif score < 0:
             action = "é€¢é«˜å–å‡º/åšç©º (CAUTIOUS SELL)"
             action_style = st.warning

        # Explicit Display
        st.subheader("ğŸ¤– AI å®æ—¶æ“ä½œå»ºè®®")
        action_style(f"ğŸ‘‰ **{action}** (ç»¼åˆå¾—åˆ†: {score})")

    dxy_df = data.get('ç¾å…ƒæŒ‡æ•° (DXY)')
    if dxy_df is not None and not dxy_df.empty:
        cur_dxy = dxy_df['Close'].iloc[-1].item()
        if len(dxy_df) >= 2:
            dxy_delta = cur_dxy - dxy_df['Close'].iloc[-2].item()
        else:
             dxy_delta = 0

        with col3:
            st.metric("ç¾å…ƒæŒ‡æ•° DXY", f"{cur_dxy:.2f}",
                      f"{dxy_delta:.2f}", delta_color="inverse")
    else:
        with col3:
            st.metric("ç¾å…ƒæŒ‡æ•° DXY", "N/A", "N/A")

    # --- 2. Detailed Logic Display ---
    st.write("### ğŸ§  å†³ç­–ä¾æ®")
    for r in reasons:
        st.write(r)

    st.divider()

    # --- 3. Macro and Policy Summary (New Section) ---
    st.write("### ğŸ›ï¸ å®è§‚æ”¿ç­–ä¸äº‹ä»¶æ€»ç»“")

    st.info("""
    **å®è§‚äº‹ä»¶ç»¼åˆæ€»ç»“ (Synthesized Summary):**
    å½“å‰å®è§‚ç¯å¢ƒä¸»è¦å—åˆ°ç¾è”å‚¨åˆ©ç‡æ”¿ç­–é¢„æœŸçš„ä¸»å¯¼ã€‚

    1.  **ç¾è”å‚¨ (Fed):** å¸‚åœºæ™®éé¢„è®¡ç¾è”å‚¨å·²ç»“æŸåŠ æ¯å‘¨æœŸï¼Œç„¦ç‚¹è½¬å‘**ä½•æ—¶å¼€å§‹é™æ¯**ã€‚è‹¥é™æ¯é¢„æœŸå¢å¼ºï¼Œå°†**å‹ä½ç¾å…ƒå’Œç¾å€ºæ”¶ç›Šç‡**ï¼Œå¯¹é»„é‡‘å½¢æˆ**é‡å¤§åˆ©å¥½**ã€‚
    2.  **ç¾å›½æ”¿åºœ (Government):** ç¾å›½æ”¿åºœçš„è´¢æ”¿æ”¯å‡ºå’Œä¸æ–­å¢é•¿çš„**å€ºåŠ¡è§„æ¨¡**æ˜¯é•¿æœŸçš„é€šèƒ€å’Œé¿é™©éœ€æ±‚æ¥æºã€‚ä»»ä½•å…³äºæ”¿åºœåœæ‘†æˆ–è´¢æ”¿åˆºæ¿€çš„æ–°é—»ï¼Œéƒ½ä¼šåœ¨çŸ­æœŸå†…**å¢åŠ é»„é‡‘çš„é¿é™©å¸å¼•åŠ›**ã€‚
    3.  **åœ°ç¼˜æ”¿æ²»:** ææ…ŒæŒ‡æ•° (VIX) è‹¥æŒç»­é«˜ä½ï¼Œè¡¨æ˜å¸‚åœºé¿é™©æƒ…ç»ªå¼ºçƒˆï¼Œç›´æ¥åˆ©å¥½ä½œä¸ºä¼ ç»Ÿé¿é™©èµ„äº§çš„é»„é‡‘ã€‚

    *è¯·ç»“åˆä¸Šæ–¹å®æ—¶æŠ€æœ¯åˆ†æå¾—åˆ†ï¼Œç»¼åˆåˆ¤æ–­ä¹°å–æ—¶æœºã€‚*
    """)

    st.write("#### ğŸ”— æƒå¨ä¿¡æ¯é€Ÿè§ˆ (Direct Links)")
    st.markdown("""
    - [ç¾è”å‚¨å®˜æ–¹ç½‘ç«™ (FOMCå£°æ˜)](https://www.federalreserve.gov/monetarypolicy/fomccalendars.htm)
    - [ç¾å›½è´¢æ”¿éƒ¨å®˜æ–¹ç½‘ç«™ (å€ºåŠ¡/é¢„ç®—)](https://home.treasury.gov/)
    - [CME FedWatchå·¥å…· (é™æ¯æ¦‚ç‡)](https://www.cmegroup.com/markets/interest-rates/cme-fedwatch-tool.html)
    """)

    st.divider()

    # --- 4. Charts and News (Existing Sections) ---
    c1, c2 = st.columns(2)

    with c1:
        st.write("### ğŸ“Š é»„é‡‘ vs ç¾å…ƒèµ°åŠ¿ (æœ€è¿‘1å‘¨)")

        # Prepare data for charting (max 168 hours = 7 days)
        g_data = gold_df['Close'].tail(168)
        d_data = data.get('ç¾å…ƒæŒ‡æ•° (DXY)', pd.DataFrame())
        d_data = d_data['Close'].tail(168)

        if not g_data.empty and not d_data.empty:
            df_chart = pd.DataFrame()
            # Normalize for comparison: (Price - Mean) / Mean
            df_chart['Gold'] = (g_data - g_data.mean()) / g_data.mean()
            df_chart['USD'] = (d_data - d_data.mean()) / d_data.mean()

            # Align indices before plotting
            df_chart = df_chart.dropna()

            st.line_chart(df_chart)
            st.caption("æ³¨ï¼šæ•°æ®å·²å½’ä¸€åŒ–ã€‚é€šå¸¸ç¾å…ƒè·Œ(æ©™çº¿)ï¼Œé»„é‡‘æ¶¨(è“çº¿)ã€‚")
        else:
             st.warning("å›¾è¡¨æ•°æ®ä¸å®Œæ•´ï¼Œæ— æ³•æ˜¾ç¤ºé»„é‡‘ä¸ç¾å…ƒå¯¹æ¯”èµ°åŠ¿ã€‚")


    with c2:
        st.write("### ğŸŒ å…¨çƒå®è§‚/æ”¿æ²»å¿«è®¯")
        if news:
            for n in news:
                st.markdown(f"**[{n['title']}]({n['link']})**")
                st.caption(f"å‘å¸ƒæ—¶é—´: {n['published']}")
        else:
            st.info("æš‚æœªæŠ“å–åˆ°æœ€æ–°çš„å®è§‚æ–°é—»ã€‚")

if __name__ == "__main__":
    main()